# # name: AWS-EC2 Instance CD

# # on:
# #   workflow_run:
# #     workflows: ["Node.js CI"]
# #     types: [completed]

# # jobs:
# #   on-success:

# #     runs-on: ubuntu-latest
# #     if: ${{ github.event.workflow_run.conclusion == 'success' }}
# #     steps:
# #       - name: AWS SSM Send-Command
# #         uses: peterkimzz/aws-ssm-send-command@v1.1.1
# #         with:
# #           # AWS access key id
# #           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
# #           # AWS secret access key
# #           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
# #           # Where EC2 instance is
# #           aws-region: ${{ secrets.AWS_REGION }}
# #           # AWS EC2 Instance id or ids
# #           instance-ids: ${{ secrets.AWS_INSTANCE_ID }}
# #           # Command execution location
# #           working-directory: /home/ec2-user
# #           # Bash command you want to execute
# #           command: |
# #             sudo docker-compose stop
# #             sudo docker-compose rm -f
# #             sudo docker-compose pull
# #             sudo docker-compose up -d
# #             sudo docker image prune -af
# #           # Comment for Send-Command
# #           comment: docker-compose.yml file re-pulls newer versions of book-portal images and runs them on the instance.
# name: Deploy via SSH (no IAM)

# on:
#   workflow_run:
#     workflows: ['Node.js CI']   # run after FE/Proxy builds succeed
#     types: [completed]
#   workflow_dispatch: {}          # allow manual "Run workflow"

# jobs:
#   deploy:
#     if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
#     runs-on: ubuntu-latest
#     steps:
#       - name: Remote docker-compose refresh
#         uses: appleboy/ssh-action@v1.2.0
#         with:
#           host: ${{ secrets.EC2_HOST }}
#           username: ${{ secrets.EC2_USER }}
#           key: ${{ secrets.EC2_KEY }}
#           script: |
#             cd /home/ubuntu
#             docker login -u ${{ secrets.DOCKER_HUB_USERNAME }} -p ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
#             docker compose stop || true
#             docker compose rm -f || true
#             docker compose pull
#             docker compose up -d
#             docker image prune -af || true
name: Deploy via SSH (no IAM)

on:
  workflow_run:
    workflows: ['Node.js CI', 'Java CI with Maven']
    types: [completed]
  workflow_dispatch:

jobs:
  deploy:
    if: ${{ (github.event.workflow_run && github.event.workflow_run.conclusion == 'success') || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    env:
      HOST: ${{ secrets.EC2_HOST }}                # Elastic IP / Public DNS
      USER: ubuntu                                  # hardcode since we know it's Ubuntu
      DH_USER: ${{ secrets.DOCKER_HUB_USERNAME }}   # rcui2
      DH_TOKEN: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
    steps:
      - name: Decode and prepare SSH key
        shell: bash
        run: |
          umask 077
          echo "${{ secrets.EC2_KEY_B64 }}" | base64 -d > key.pem
          # normalize line endings just in case
          sed -i 's/\r$//' key.pem
          chmod 600 key.pem
          
          # Debug: Check key format and length
          echo "Key file created, verifying..."
          echo "File size: $(wc -c < key.pem) bytes"
          echo "First line: $(head -1 key.pem)"
          echo "Last line: $(tail -1 key.pem)"
          
          # Validate key format
          if ssh-keygen -l -f key.pem >/dev/null 2>&1; then
            echo "‚úÖ Key format is valid"
          else
            echo "‚ùå Key format validation failed"
            echo "Key content preview (first 100 chars):"
            head -c 100 key.pem
            exit 1
          fi
          
          # Store decoded key in environment variable for the SSH action
          echo "DECODED_SSH_KEY<<EOF" >> $GITHUB_ENV
          cat key.pem >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Simple SSH test (minimal options)
        shell: bash
        timeout-minutes: 2
        continue-on-error: true
        run: |
          echo "Testing basic SSH connection with minimal options..."
          ssh -o ConnectTimeout=15 -o StrictHostKeyChecking=no -i key.pem "$USER@$HOST" 'echo "Basic SSH works!"'

      - name: Comprehensive connectivity test
        shell: bash
        timeout-minutes: 3
        run: |
          echo "=== Testing connectivity to $HOST ==="
          
          # Get current GitHub Actions runner IP
          echo "0. Current GitHub Actions runner IP:"
          RUNNER_IP=$(curl -s ifconfig.me || curl -s ipinfo.io/ip || echo "unknown")
          echo "Runner IP: $RUNNER_IP"
          
          # Get GitHub IP ranges for reference (with error handling)
          echo "1. GitHub Actions IP ranges (sample):"
          curl -s https://api.github.com/meta | jq -r '.actions[]' 2>/dev/null | head -5 || echo "Could not fetch GitHub IP ranges"
          
          # Test basic network connectivity
          echo "2. Testing DNS resolution..."
          nslookup "$HOST" || echo "DNS resolution failed"
          
          echo "3. Testing ping connectivity..."
          ping -c 3 -W 5 "$HOST" || echo "Ping failed (normal for EC2)"
          
          echo "4. Testing port 22 connectivity..."
          timeout 10 bash -c "echo >/dev/tcp/$HOST/22" && echo "‚úÖ Port 22 is open" || echo "‚ùå Port 22 is not reachable"
          
          echo "5. Testing SSH with reduced timeout..."
          timeout 30 ssh -vvv -o ConnectTimeout=10 -o ServerAliveInterval=5 -o ServerAliveCountMax=2 -o StrictHostKeyChecking=no -o BatchMode=yes -i key.pem "$USER@$HOST" 'echo "SSH connection successful!"' && {
            echo "‚úÖ SSH connection successful!"
            exit 0
          } || {
            echo "‚ùå SSH connection failed"
            echo ""
            echo "üîç DIAGNOSIS: Runner IP $RUNNER_IP cannot complete SSH handshake"
            echo ""
            echo "üõ†Ô∏è  Your security group shows 0.0.0.0/0 but the connection still fails."
            echo "This could be:"
            echo "   - Network ACLs blocking the connection"
            echo "   - VPC routing issues"
            echo "   - SSH service configuration issues"
            echo "   - Instance in private subnet without proper NAT gateway"
            echo ""
            echo "üìç Next steps:"
            echo "   1. Check Network ACLs in your VPC"
            echo "   2. Verify instance is in a public subnet"
            echo "   3. Check VPC route table has 0.0.0.0/0 ‚Üí Internet Gateway"
            echo "   4. Try connecting from EC2 Instance Connect to test SSH service"
            exit 1
          }

      - name: Alternative deployment via AWS Systems Manager (if SSH fails and AWS secrets available)
        if: failure() && secrets.AWS_ACCESS_KEY_ID != '' && secrets.AWS_SECRET_ACCESS_KEY != '' && secrets.AWS_REGION != '' && secrets.AWS_INSTANCE_ID != ''
        uses: peterkimzz/aws-ssm-send-command@v1.1.1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          instance-ids: ${{ secrets.AWS_INSTANCE_ID }}
          working-directory: /home/ubuntu
          command: |
            echo "Deploying via Systems Manager..."
            docker login -u "${{ env.DH_USER }}" -p "${{ env.DH_TOKEN }}"
            docker compose pull
            docker compose up -d
            docker image prune -af || true
            echo "Deployment completed via SSM!"

      - name: Deploy via SSH (only if connectivity test passed)
        if: success()
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ env.HOST }}
          username: ${{ env.USER }}
          key: ${{ env.DECODED_SSH_KEY }}
          timeout: 300s
          command_timeout: 120s
          script: |
            echo "Starting deployment on $(hostname)..."
            set -e
            cd /home/ubuntu
            docker login -u "${{ env.DH_USER }}" -p "${{ env.DH_TOKEN }}"
            docker compose pull
            docker compose up -d
            docker image prune -af || true
            echo "Deployment completed successfully!"

